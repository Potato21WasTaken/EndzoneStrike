--[[
	RedemptionService.lua
	
	Service for handling Discord code redemption in Roblox.
	This module communicates with the backend API to redeem codes generated by Discord users.
	
	Usage:
		local RedemptionService = require(path.to.RedemptionService)
		
		-- Initialize with your backend URL and API key
		RedemptionService.Initialize("https://your-backend.com", "your-server-secret")
		
		-- Redeem a code for a player
		RedemptionService.RedeemCode(player, "ABC12XYZ"):andThen(function(reward)
			print("Code redeemed! Coins:", reward.coins)
			-- Give rewards to player
		end):catch(function(errorMessage)
			warn("Redemption failed:", errorMessage)
		end)
]]

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

local RedemptionService = {}
RedemptionService.__index = RedemptionService

-- Configuration
local BACKEND_URL = nil
local API_KEY = nil
local INITIALIZED = false

--[[
	Initialize the redemption service
	@param backendUrl (string) - The URL of your backend API (e.g., "https://api.example.com")
	@param apiKey (string) - Your SERVER_SECRET from the backend
]]
function RedemptionService.Initialize(backendUrl, apiKey)
	assert(type(backendUrl) == "string", "backendUrl must be a string")
	assert(type(apiKey) == "string", "apiKey must be a string")
	
	BACKEND_URL = backendUrl:gsub("/$", "") -- Remove trailing slash
	API_KEY = apiKey
	INITIALIZED = true
	
	print("[RedemptionService] Initialized with backend:", BACKEND_URL)
end

--[[
	Check if the service is initialized
	@return (boolean) - True if initialized, false otherwise
]]
function RedemptionService.IsInitialized()
	return INITIALIZED
end

--[[
	Redeem a code for a player
	@param player (Player) - The player redeeming the code
	@param code (string) - The code to redeem
	@return (Promise) - Promise that resolves with reward data or rejects with error message
]]
function RedemptionService.RedeemCode(player, code)
	assert(INITIALIZED, "[RedemptionService] Service not initialized. Call Initialize() first.")
	assert(typeof(player) == "Instance" and player:IsA("Player"), "player must be a Player instance")
	assert(type(code) == "string", "code must be a string")
	
	-- Return a promise-like object
	local promise = {}
	local success = false
	local result = nil
	local errorMsg = nil
	
	-- Normalize code (uppercase, trim whitespace)
	local normalizedCode = code:upper():gsub("^%s*(.-)%s*$", "%1")
	
	if normalizedCode == "" then
		errorMsg = "Code cannot be empty"
		promise.success = false
		promise.error = errorMsg
	else
		-- Make HTTP request to backend
		local url = BACKEND_URL .. "/redeem-code"
		local requestBody = HttpService:JSONEncode({
			code = normalizedCode,
			robloxUserId = tostring(player.UserId)
		})
		
		local requestSuccess, response = pcall(function()
			return HttpService:RequestAsync({
				Url = url,
				Method = "POST",
				Headers = {
					["Content-Type"] = "application/json",
					["x-api-key"] = API_KEY
				},
				Body = requestBody
			})
		end)
		
		if requestSuccess then
			if response.Success then
				-- Parse response body
				local parseSuccess, data = pcall(function()
					return HttpService:JSONDecode(response.Body)
				end)
				
				if parseSuccess and data.ok then
					success = true
					result = data.reward
					promise.success = true
					promise.data = result
					print(string.format("[RedemptionService] Code '%s' redeemed by %s (UserId: %d)", 
						normalizedCode, player.Name, player.UserId))
				else
					errorMsg = data.message or "Invalid response from server"
					promise.success = false
					promise.error = errorMsg
				end
			else
				-- Handle HTTP error responses
				local parseSuccess, errorData = pcall(function()
					return HttpService:JSONDecode(response.Body)
				end)
				
				if parseSuccess and errorData.error then
					if errorData.error == "code_already_used" then
						errorMsg = "This code has already been redeemed"
					elseif response.StatusCode == 404 then
						errorMsg = "Invalid code"
					elseif response.StatusCode == 403 then
						errorMsg = "Server authentication failed"
					else
						errorMsg = errorData.message or "Failed to redeem code"
					end
				else
					errorMsg = string.format("HTTP %d: %s", response.StatusCode, response.StatusMessage)
				end
				
				promise.success = false
				promise.error = errorMsg
			end
		else
			-- Request failed (network error, etc.)
			errorMsg = "Failed to connect to redemption server"
			promise.success = false
			promise.error = errorMsg
			warn("[RedemptionService] Request failed:", response)
		end
	end
	
	-- Promise-like interface
	function promise:andThen(callback)
		if self.success then
			local callSuccess, callResult = pcall(callback, self.data)
			if not callSuccess then
				warn("[RedemptionService] Error in andThen callback:", callResult)
			end
		end
		return self
	end
	
	function promise:catch(callback)
		if not self.success then
			local callSuccess, callResult = pcall(callback, self.error)
			if not callSuccess then
				warn("[RedemptionService] Error in catch callback:", callResult)
			end
		end
		return self
	end
	
	return promise
end

--[[
	Check the status of a code (for debugging)
	@param code (string) - The code to check
	@return (table|nil, string|nil) - Status data or nil, error message or nil
]]
function RedemptionService.CheckCodeStatus(code)
	assert(INITIALIZED, "[RedemptionService] Service not initialized. Call Initialize() first.")
	assert(type(code) == "string", "code must be a string")
	
	local normalizedCode = code:upper():gsub("^%s*(.-)%s*$", "%1")
	local url = BACKEND_URL .. "/code-status?code=" .. HttpService:UrlEncode(normalizedCode)
	
	local requestSuccess, response = pcall(function()
		return HttpService:RequestAsync({
			Url = url,
			Method = "GET"
		})
	end)
	
	if requestSuccess and response.Success then
		local parseSuccess, data = pcall(function()
			return HttpService:JSONDecode(response.Body)
		end)
		
		if parseSuccess then
			return data, nil
		else
			return nil, "Failed to parse response"
		end
	else
		return nil, "Failed to check code status"
	end
end

--[[
	Give rewards to a player (implement your own reward logic here)
	@param player (Player) - The player to give rewards to
	@param reward (table) - The reward data from the backend
]]
function RedemptionService.GiveRewards(player, reward)
	-- Example implementation - customize this for your game!
	
	print(string.format("[RedemptionService] Giving rewards to %s:", player.Name))
	print(" - Coins:", reward.coins or 0)
	print(" - Items:", HttpService:JSONEncode(reward.items or {}))
	
	-- Example: Give coins
	if reward.coins then
		local leaderstats = player:FindFirstChild("leaderstats")
		if leaderstats then
			local coins = leaderstats:FindFirstChild("Coins")
			if coins then
				coins.Value = coins.Value + reward.coins
			end
		end
	end
	
	-- Example: Give items
	if reward.items and #reward.items > 0 then
		-- Implement your item-giving logic here
		-- This will depend on your game's inventory system
	end
	
	-- You can also store the Discord ID for future use
	if reward.discordId then
		-- Save to DataStore or player data
		print(" - Linked Discord ID:", reward.discordId)
	end
end

return RedemptionService
